"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Game;

Game = function () {
  function Game(width1, height) {
    _classCallCheck(this, Game);

    this.width = width1;
    this.height = height;
    this.level = 1;
    this.ring = true;
    this.bg = 0;
    this.stopp = Date.now();
    this.init(0);
  }

  _createClass(Game, [{
    key: "init",
    value: function init(dlevel) {
      this.start = this.stopp;
      this.stopp = Date.now();
      this.level += dlevel;
      this.level = constrain(this.level, 1, 64);
      this.circles = [];
      this.marked = null; // Marked Circle
      return this.select_colors();
    }
  }, {
    key: "select_colors",
    value: function select_colors() {
      var b, col, colors, h, i, index, j, k, len, len1, radius, ref, ref1, results, s;
      //n=4
      //if @level < 3*3*3 then n=3
      //if @level < 2*2*2 then n=2
      radius = width / (0.7 + this.level);
      colors = [];
      ref = range(this.level);
      // for i in range n
      // 	for j in range n
      // 		for k in range n
      // r = int 255*i/(n-1)
      // g = int 255*j/(n-1)
      // b = int 255*k/(n-1)
      // if i+j+k>0 then colors.push color r,g,b,127.5
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        h = int(360 * i / this.level);
        s = 100;
        b = 100;
        colors.push(color(h, s, b, 0.5));
      }
      ref1 = range(this.level);
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        i = ref1[k];
        index = int(random(0, colors.length - 1));
        col = colors[index];
        colors.splice(index, 1);
        this.circles.push(new Circle(col, radius, this.circles));
        results.push(this.circles.push(new Circle(col, radius, this.circles)));
      }
      return results;
    }
  }, {
    key: "mousePressed",
    value: function mousePressed() {
      var c, cc, circle, count, i, index, j, len, n, ref;
      // You must only mark one circle
      // The second circle must have the same color as the first one.
      n = this.circles.length;
      count = 0;
      ref = this.circles;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        c = ref[i];
        if (c.within(mouseX, mouseY)) {
          cc = c;
          index = i;
          count += 1;
        }
      }
      this.circles = function () {
        var k, len1, ref1, results;
        ref1 = this.circles;
        results = [];
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          circle = ref1[i];
          if (i !== index) {
            results.push(circle);
          }
        }
        return results;
      }.call(this);
      if (count !== 1) {
        this.init(-1);
        return;
      }
      if (this.marked === null) {
        return this.marked = cc.col;
      } else if (cc.col === this.marked) {
        this.marked = null;
        if (this.circles.length === 0) {
          return this.init(1); // Win
        }
      } else {
        return this.init(-1); // Lose
      }
    }
  }]);

  return Game;
}();
//# sourceMappingURL=game.js.map
