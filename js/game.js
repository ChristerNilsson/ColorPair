"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Game;

Game = function () {
  function Game(width1, height) {
    _classCallCheck(this, Game);

    this.width = width1;
    this.height = height;
    this.level = 1;
    this.ring = true;
    this.bg = 0;
    this.stopp = Date.now();
    this.init(0);
  }

  _createClass(Game, [{
    key: "init",
    value: function init(dlevel) {
      this.start = this.stopp;
      this.stopp = Date.now();
      this.level += dlevel;
      this.level = constrain(this.level, 1, 64);
      this.circles = [];
      this.marked = null; // Marked Circle
      return this.select_colors();
    }
  }, {
    key: "select_colors",
    value: function select_colors() {
      var b, col, colors, g, i, index, j, k, l, len, len1, len2, len3, m, n, o, p, r, radius, ref, ref1, ref2, ref3, results;
      n = 4;
      if (this.level < 3 * 3 * 3) {
        n = 3;
      }
      if (this.level < 2 * 2 * 2) {
        n = 2;
      }
      radius = width / (0.7 + this.level);
      colors = [];
      ref = range(n);
      for (l = 0, len = ref.length; l < len; l++) {
        i = ref[l];
        ref1 = range(n);
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          j = ref1[m];
          ref2 = range(n);
          for (o = 0, len2 = ref2.length; o < len2; o++) {
            k = ref2[o];
            r = int(255 * i / (n - 1));
            g = int(255 * j / (n - 1));
            b = int(255 * k / (n - 1));
            if (i + j + k > 0) {
              colors.push(color(r, g, b, 127.5));
            }
          }
        }
      }
      ref3 = range(this.level);
      results = [];
      for (p = 0, len3 = ref3.length; p < len3; p++) {
        i = ref3[p];
        index = int(random(0, colors.length - 1));
        col = colors[index];
        colors.splice(index, 1);
        this.circles.push(new Circle(col, radius, this.circles));
        results.push(this.circles.push(new Circle(col, radius, this.circles)));
      }
      return results;
    }
  }, {
    key: "mousePressed",
    value: function mousePressed() {
      var c, cc, circle, count, i, index, l, len, n, ref;
      // You must only mark one circle
      // The second circle must have the same color as the first one.
      n = this.circles.length;
      count = 0;
      ref = this.circles;
      for (i = l = 0, len = ref.length; l < len; i = ++l) {
        c = ref[i];
        if (c.within(mouseX, mouseY)) {
          cc = c;
          index = i;
          count += 1;
        }
      }
      this.circles = function () {
        var len1, m, ref1, results;
        ref1 = this.circles;
        results = [];
        for (i = m = 0, len1 = ref1.length; m < len1; i = ++m) {
          circle = ref1[i];
          if (i !== index) {
            results.push(circle);
          }
        }
        return results;
      }.call(this);
      if (count !== 1) {
        this.init(-1);
        return;
      }
      if (this.marked === null) {
        return this.marked = cc.col;
      } else if (cc.col === this.marked) {
        this.marked = null;
        if (this.circles.length === 0) {
          return this.init(1); // Win
        }
      } else {
        return this.init(-1); // Lose
      }
    }
  }]);

  return Game;
}();
//# sourceMappingURL=game.js.map
